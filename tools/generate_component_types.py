"""
Examples:
python .\opus\tools\generate_component_types.py --data "$HOME\source\github\enginefire\src\game_components.h" "$HOME\source\github\enginefire\opus\ecs\reserved_components.h" --out="$HOME\source\github\enginefire\src\generated"
"""
import sys
import os
import argparse
import re

def log_info(message):
    print(f"[info] {message}")

def parse_sprite_name(filename):
    # 'basic/base_robot_4.png' -> 'BASE_ROBOT_4'
    return filename.split('/')[-1].split('.')[0].upper()

def parse_animation_name(filename):
    # 'basic/base_robot_4.png' -> 'BASE_ROBOT'
    return "_".join(parse_sprite_name(filename).split('_')[:-1]).upper()

def camel_to_snake(name):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Opus Component Header Generator")
    parser.add_argument("--data", type=str, help="Component header file", required=True)
    parser.add_argument("--event-data", type=str, help="Event header file")
    parser.add_argument("--out", type=str, help="Output path", required=True)
    args = parser.parse_args()

    out_header = os.path.join(args.out, 'component_types.h')
    if os.path.exists(out_header):
        os.remove(out_header)
        
    out_source = os.path.join(args.out, 'component_types.c')
    if os.path.exists(out_source):
        os.remove(out_source)
        
    out_events_header = os.path.join(args.out, 'events.h')
    if os.path.exists(out_events_header):
        os.remove(out_events_header)
        
    out_events_source = os.path.join(args.out, 'events.c')
    if os.path.exists(out_events_source):
        os.remove(out_events_source)
        
    component_types = []
    tag_component_types = []
    event_types = []
    if args.event_data:
        with  open(args.event_data, 'r') as event_data_file:
            data_contents = event_data_file.read()
            matches = re.findall(r'(?<=}\s)\w+(?=;)', data_contents)
            for match in matches:
                event_types.append(match)
        
    with open(args.data, 'r') as data_file:
        data_contents = data_file.read()
        matches = re.findall(r'(?<=}\s)\w+(?=;)', data_contents)
        for match in matches:
            component_types.append(match)
            
        matches = re.findall(r'(?<=TagComponent\s)\w+(?=;)', data_contents)
        for match in matches:
            tag_component_types.append(match)
        
    with open(out_header, 'w') as header_file, open(out_source, 'w') as source_file:
        # write header
        header_file.writelines(["/**\n", " * IMPORTANT:\n", " * THIS FILE IS AUTO GENERATED\n", " * DO NOT EDIT THIS FILE BY HAND\n", " */\n"])
        header_file.write("#pragma once\n\n")

        header_file.write("#include <core/defines.h>\n")
        header_file.write("#include <ecs/component.h>\n\n")
        header_file.write(f"#include \"{os.path.relpath(args.data, args.out)}\"\n")

        if len(component_types) == 0:
            sys.exit()

        header_file.write("\nenum\n{\n")
        header_file.write(f"\tCT_{component_types[0]} = CT_RESERVE_COUNT,\n")
        for component_type in component_types[1:]:
            header_file.write(f"\tCT_{component_type},\n")
        for component_type in tag_component_types:
            header_file.write(f"\tCTT_{component_type},\n")
        header_file.write("\tCT_COUNT\n};\n")
    
        header_file.write("\ninternal void register_components(Arena* temp_arena, ComponentTypeManager* type_manager);")
            
        source_file.write("#include \"component_types.h\"\n")
        source_file.write("\ninternal void")
        source_file.write("\nregister_components(Arena* temp_arena, ComponentTypeManager* type_manager)\n{\n")
        source_file.write("\tComponentTypeRegistrationRequest* request = component_type_register_begin(temp_arena);\n")
        for component_type in component_types:
            source_file.write(f"\tcomponent_type_register_add(request, CT_{component_type}, sizeof({component_type}), ComponentDataTypeDefault);\n")
        for component_type in tag_component_types:
            source_file.write(f"\tcomponent_type_register_add(request, CTT_{component_type}, 0, ComponentDataTypeTag);\n")
        source_file.write("\tcomponent_type_register_complete(type_manager, request);\n}")
    
            
    if len(event_types) > 0:
        with open(out_events_header, 'w') as header_file, open(out_events_source, 'w') as source_file:
            header_file.writelines(["/**\n", " * IMPORTANT:\n", " * THIS FILE IS AUTO GENERATED\n", " * DO NOT EDIT THIS FILE BY HAND\n", " */\n"])
            header_file.write("#pragma once\n\n")

            header_file.write("#include <core/defines.h>\n")
            header_file.write("#include <ecs/component.h>\n")
            header_file.write("#include <ecs/events.h>\n\n")
        
            header_file.write(f"#include \"{os.path.relpath(args.event_data, args.out)}\"\n")
                            
            header_file.write("\nenum\n{\n")
            header_file.write(f"\tET_{event_types[0]} = ET_RESERVE_COUNT,\n")
            for event_type in event_types[1:]:
                header_file.write(f"\tET_{event_type},\n")
            header_file.write("\tET_COUNT\n};\n")
            header_file.write("\ninternal void register_events(EventManager* event_manager);\n\n")
            for event_type in event_types:
                header_file.write(f"internal inline void fire_{camel_to_snake(event_type)}(EventManager* event_manager, ComponentTypeField types, {event_type} data);\n")            
                
            source_file.write("#include \"events.h\"\n")
            source_file.write("\ninternal void")
            source_file.write("\nregister_events(EventManager* event_manager)\n{\n")
            for event_type in event_types:
                source_file.write(f"\tevent_manager_initialize_event_type(event_manager, ET_{event_type}, sizeof({event_type}));\n")
            source_file.write("}\n")
                
            for event_type in event_types:
                source_file.write("\ninternal inline void")
                source_file.write(f"\nfire_{camel_to_snake(event_type)}(EventManager* event_manager, ComponentTypeField types, {event_type} data)\n{{")
                source_file.write(f"\n\tevent_manager_fire(event_manager, ET_{event_type}, types, &data);\n}}\n")
            
            
            
            
            
    print(f"[info] generated header successfully at '{os.path.abspath(args.out)}'")

